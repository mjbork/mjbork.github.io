<script>
  /* =========================
     INTERACTIVE DOT FIELD (v2)
     - Dots invisible at rest
     - Bloom near a smoothed cursor
     - Trail is wider + slower/smoother
     ========================= */
  (function(){
    const canvas = document.getElementById('fx');
    const ctx = canvas.getContext('2d');
    let dpr = Math.min(window.devicePixelRatio || 1, 2);
    let W, H, dots = [], sparks = [];

    // Smoothed cursor (target tx/ty -> rendered x/y)
    const cursor = { tx:-1e9, ty:-1e9, x:-1e9, y:-1e9, vx:0, vy:0 };
    let activity = 0; // 0..1

    const CFG = {
      gap: 48,
      baseSize: 2.1,
      maxRadius: 120,     // influence radius base (before dpr)
      jitter: 0.7,
      repel: 0.11,

      // Trail tuning (wider, slower, smoother)
      sparkRate: 4,       // fewer per event (less “firework”)
      sparkLife: 950,     // longer life => slower fade
      sparkSpread: 36,    // radial spread range
      sparkOffset: 10,    // minimum offset from cursor
      sparkDamping: 0.985,
      sparkGravity: 0.004
    };

    function resize(){
      W = canvas.width = Math.floor(innerWidth * dpr);
      H = canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = innerWidth+'px';
      canvas.style.height = innerHeight+'px';
      initDots();
    }

    function initDots(){
      dots = [];
      const cols = Math.ceil(innerWidth / CFG.gap) + 2;
      const rows = Math.ceil(innerHeight / CFG.gap) + 2;
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          const px = (x*CFG.gap + (y%2? CFG.gap/2:0)) * dpr;
          const py = (y*CFG.gap + 20) * dpr;
          dots.push({ x:px, y:py, ox:px, oy:py, vx:0, vy:0, n: Math.random()*1000 });
        }
      }
    }

    function addSparks(mx,my, speed=0.4){
      for(let i=0;i<CFG.sparkRate;i++){
        // spawn around cursor with radial offset so it’s not a pinpoint
        const theta = Math.random()*Math.PI*2;
        const r0 = CFG.sparkOffset + Math.random()*CFG.sparkSpread;
        const px = (mx + Math.cos(theta)*r0) * dpr;
        const py = (my + Math.sin(theta)*r0) * dpr;

        // lower initial speed, spread outward, slight upward bias removed
        const vmag = Math.random()*(speed*0.6) + 0.18;
        const vx = Math.cos(theta)*vmag;
        const vy = Math.sin(theta)*vmag;

        sparks.push({
          x:px, y:py, vx, vy,
          life: CFG.sparkLife,
          born: performance.now(),
          size: Math.random()*1.1 + 0.7
        });
      }
    }

    function step(ts){
      ctx.clearRect(0,0,W,H);

      // Smooth the cursor to make motion fluid
      if(cursor.x === -1e9){ cursor.x = cursor.tx; cursor.y = cursor.ty; }
      cursor.x += (cursor.tx - cursor.x) * 0.15;
      cursor.y += (cursor.ty - cursor.y) * 0.15;

      // Activity decays when idle
      activity = Math.max(0, activity - 0.012);

      const radius = (CFG.maxRadius + Math.sin(ts/900)*16 + Math.cos(ts/700)*10) * dpr;

      // Dots (only drawn near cursor, and only if active)
      if(activity > 0.05){
        for(const p of dots){
          // gentle return to origin + tiny wander
          const dx0 = p.ox - p.x, dy0 = p.oy - p.y;
          p.vx += dx0 * 0.002 + (Math.sin(p.n + ts*0.001)-0.5)*CFG.jitter*0.01;
          p.vy += dy0 * 0.002 + (Math.cos(p.n + ts*0.001)-0.5)*CFG.jitter*0.01;

          // repel from smoothed cursor
          const dx = p.x - cursor.x, dy = p.y - cursor.y;
          const dist = Math.hypot(dx,dy);
          if(dist < radius){
            const f = (1 - dist/radius) * CFG.repel * (0.7 + activity*0.6);
            p.vx += (dx/dist || 0) * f * 3.0;
            p.vy += (dy/dist || 0) * f * 3.0;
          }

          // integrate
          p.vx *= 0.965; p.vy *= 0.965;
          p.x += p.vx;    p.y += p.vy;

          // draw only if near cursor (size/alpha scale by proximity & activity)
          if(dist < radius){
            const near = 1 - dist/radius; // 0..1
            const s = CFG.baseSize * (near*0.85 + 0.25) * activity;
            if(s > 0.12){
              ctx.beginPath();
              ctx.arc(p.x, p.y, s*dpr, 0, Math.PI*2);
              const alpha = 0.12 + near*0.38*activity;
              ctx.fillStyle = `rgba(191,185,174,${alpha})`;
              ctx.fill();
            }
          }
        }
      }

      // Sparks (wider, slower)
      const now = ts;
      for(let i=sparks.length-1;i>=0;i--){
        const sp = sparks[i];
        const age = now - sp.born;
        if(age > sp.life){ sparks.splice(i,1); continue; }

        sp.vy += CFG.sparkGravity;             // gentle gravity
        sp.vx *= CFG.sparkDamping;             // smooth damping
        sp.vy *= CFG.sparkDamping;
        sp.x  += sp.vx;
        sp.y  += sp.vy;

        const t = 1 - age/sp.life;             // 1..0
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, sp.size*dpr*(0.8 + 0.2*t), 0, Math.PI*2);
        ctx.fillStyle = `rgba(191,185,174,${0.28 * t})`;
        ctx.fill();
      }

      requestAnimationFrame(step);
    }

    // Mouse events → update target cursor (smoothed later) + spawn sparks
    window.addEventListener('mousemove', e => {
      // velocity magnitude for activity bump
      const vx = e.movementX || 0, vy = e.movementY || 0;
      const mag = Math.min(1, Math.hypot(vx, vy)/36);
      activity = Math.min(1, activity + 0.18 + mag*0.55);

      cursor.tx = e.clientX * dpr;
      cursor.ty = e.clientY * dpr;

      addSparks(e.clientX, e.clientY, 0.32 + mag*0.35);
    }, {passive:true});

    window.addEventListener('mouseleave', () => {
      cursor.tx = cursor.ty = -1e9;
    });

    window.addEventListener('resize', resize);
    resize();
    requestAnimationFrame(step);
  })();
</script>
