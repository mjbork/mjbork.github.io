<script>
/* =========================================================
   MESH ONLY WHILE MOVING  •  FAST IDLE FADE
   - Mesh (dots + links + base grid) draws ONLY when pointer moves
   - After ~80ms of no movement, mesh is hidden and effect fades quickly
   - Title + subtitle distort smoothly as one unit; "learn more" stays steady
========================================================= */
(function(){
  const canvas = document.getElementById('fx');
  const ctx = canvas.getContext('2d');

  /* ---------- Mesh appearance ---------- */
  const DOT_RGB   = '120,120,120';
  const GAP       = 42;
  const CLUSTER_N = 10;
  const CLUSTER_R = 5.5;
  const MICRO_R   = [0.45, 1.0];
  const DOT_ALPHA = 0.26;

  const DRAW_LINKS       = true;
  const LINK_ALPHA_BASE  = 0.14;
  const LINK_RADIUS      = 240;

  const DRAW_BASE_GRID   = true;     // will be gated by movement
  const BASE_GRID_ALPHA  = 0.035;
  const BASE_GRID_STEP   = 1;

  /* ---------- Physics ---------- */
  const DAMP   = 0.978;
  const SPRING = 0.0065;
  const NOISE  = 0.004;

  // Cursor influence on mesh
  const INFL_R    = 210;
  const PUSH      = 0.34;
  const RADIAL    = 0.60;
  const TANGENTIAL= 0.10;
  const ALONG     = 0.16;

  /* ---------- Visibility & movement gating ---------- */
  let activity = 0;                   // 0..1
  const MOVE_BOOST      = 0.16;
  const SPEED_GAIN      = 0.55;
  const ACTIVITY_DECAY  = 0.012;      // normal decay
  const ACTIVITY_DECAY_IDLE = 0.02;   // faster decay when fully idle
  const DEAD_EPS        = 0.05;       // hide when below this threshold

  let isMoving = false;               // hard gate for drawing
  let idleTimer = null;
  const IDLE_AFTER_MS = 80;           // how long after last move we consider idle

  /* ---------- State ---------- */
  let dpr = Math.min(window.devicePixelRatio || 1, 2);
  let W=0, H=0, cols=0, rows=0;
  const nodes = [];

  // Cursor + smoothing
  const cursor = { tx:null, ty:null, x:null, y:null, px:0, py:0, vx:0, vy:0 };
  const EASE = 0.12;

  // Distorted copy group (title + subtitle)
  const copyGroup = document.getElementById('copyGroup');
  const G = { x:0, y:0, sx:1, sy:1, skew:0, blur:0,  vx:0, vy:0, vs:0, vsk:0, vb:0 };

  function resize(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = canvas.width  = Math.max(1, Math.floor(innerWidth  * dpr));
    H = canvas.height = Math.max(1, Math.floor(innerHeight * dpr));
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';

    nodes.length = 0;
    cols = Math.ceil(innerWidth / GAP) + 2;
    rows = Math.ceil(innerHeight/ GAP) + 2;

    for(let j=0;j<rows;j++){
      for(let i=0;i<cols;i++){
        const ox_css = i*GAP + (j%2 ? GAP/2 : 0);
        const oy_css = j*GAP + 20;
        const x = ox_css * dpr, y = oy_css * dpr;

        const cluster = [];
        for(let k=0;k<CLUSTER_N;k++){
          const a = (k/CLUSTER_N)*Math.PI*2 + Math.random()*0.6;
          const rr = (CLUSTER_R*(0.55 + Math.random()*0.45));
          cluster.push({ ox: Math.cos(a)*rr, oy: Math.sin(a)*rr, r: (MICRO_R[0] + Math.random()*(MICRO_R[1]-MICRO_R[0])) });
        }
        nodes.push({ x, y, ox:x, oy:y, vx:0, vy:0, cluster });
      }
    }
  }

  function updateCopyGroup(dt){
    if(!copyGroup) return;

    const rect = copyGroup.getBoundingClientRect();
    const cx = cursor.x, cy = cursor.y;
    let tx=0, ty=0, tskew=0, ts=1, tblur=0;

    if(cx != null && isMoving){
      const ex = rect.left + rect.width/2;
      const ey = rect.top  + rect.height/2;
      const dx = ex - cx, dy = ey - cy;
      const R  = 300;
      const d2 = dx*dx + dy*dy;

      if(d2 < R*R){
        const fall = Math.exp(-d2/(2*R*R));
        const vmag = Math.hypot(cursor.vx, cursor.vy) || 1e-6;
        const ux = cursor.vx/vmag, uy = cursor.vy/vmag;   // along motion
        const len = Math.max(1e-6, Math.hypot(dx,dy));
        const rx = dx/len, ry = dy/len;                   // radial away

        const maxShift = 14;
        tx = (rx*0.7 + ux*0.3) * maxShift * fall * activity;
        ty = (ry*0.7 + uy*0.3) * maxShift * fall * activity;

        tskew = (ux*ry - uy*rx) * 3.2 * fall * activity;  // deg
        ts    = 1 + 0.012 * fall * activity;              // up to +1.2%
        tblur = Math.min(1.0, 0.8 * fall * activity);     // px
      }
    }
    // If idle, aggressively relax blur to 0 so the text looks crisp
    if(!isMoving){ tblur = 0; }

    // Critically damped spring
    const zeta = 1.0, omega = 8.0, k = omega*omega, c = 2*zeta*omega;
    function spring(p, v, target){ const a = -k*(p-target) - c*v; v += a*dt; p += v*dt; return [p,v]; }

    [G.x, G.vx]   = spring(G.x, G.vx,   tx);
    [G.y, G.vy]   = spring(G.y, G.vy,   ty);
    [G.skew,G.vsk]= spring(G.skew,G.vsk,tskew);
    [G.sx, G.vs]  = spring(G.sx, G.vs,  ts);
    G.sy = 1 / Math.max(0.0001, G.sx);
    [G.blur,G.vb] = spring(G.blur,G.vb, tblur);

    copyGroup.style.transform =
      `translate3d(${G.x}px, ${G.y}px, 0) ` +
      `skew(${G.skew}deg, 0deg) ` +
      `scale(${G.sx}, ${G.sy})`;

    copyGroup.style.filter = (isMoving && activity > DEAD_EPS && G.blur > 0.03)
      ? `blur(${G.blur}px) contrast(${1 + 0.05*G.blur})`
      : 'none';
  }

  function step(ts){
    if(!step.t0) step.t0 = ts;
    const dt = Math.min(0.033, Math.max(0.001, (ts - step.t0)/1000));
    step.t0 = ts;

    // Cursor smoothing + activity
    if(cursor.tx != null){
      if(cursor.x == null){ cursor.x = cursor.tx; cursor.y = cursor.ty; cursor.px = cursor.x; cursor.py = cursor.y; }
      cursor.x += (cursor.tx - cursor.x) * EASE;
      cursor.y += (cursor.ty - cursor.y) * EASE;
      cursor.vx = (cursor.x - cursor.px);
      cursor.vy = (cursor.y - cursor.py);
      const vmag = Math.hypot(cursor.vx, cursor.vy);
      activity = Math.min(1, activity + MOVE_BOOST + SPEED_GAIN * Math.min(1, vmag/28));
      cursor.px = cursor.x; cursor.py = cursor.y;
    }

    // If idle, decay faster
    activity = Math.max(0, activity - (isMoving ? ACTIVITY_DECAY : ACTIVITY_DECAY_IDLE));

    ctx.clearRect(0,0,W,H);

    // If not moving or too faint → hide mesh entirely, but still relax copyGroup
    if(!isMoving || activity <= DEAD_EPS){
      updateCopyGroup(dt);
      requestAnimationFrame(step);
      return;
    }

    // Draw with fade gate (only when moving)
    const gate = Math.pow(activity, 1.15);
    const infl2 = INFL_R*INFL_R;
    const link2 = LINK_RADIUS*LINK_RADIUS;

    const vmag = Math.hypot(cursor.vx, cursor.vy) || 1e-6;
    const ux = cursor.vx/vmag, uy = cursor.vy/vmag;
    const txv = -uy, tyv = ux;

    // Update nodes
    for(let n of nodes){
      n.vx += (n.ox - n.x) * SPRING;
      n.vy += (n.oy - n.y) * SPRING;

      const dx = (n.x/dpr - cursor.x);
      const dy = (n.y/dpr - cursor.y);
      const d2 = dx*dx + dy*dy;
      if(d2 < infl2){
        const fall = Math.exp(-d2/(2*infl2));
        const rlen = Math.max(1e-6, Math.hypot(dx,dy));
        const rx = dx/rlen, ry = dy/rlen;
        const mag = PUSH * fall * dpr;
        n.vx += (rx*RADIAL + txv*TANGENTIAL + ux*ALONG) * mag;
        n.vy += (ry*RADIAL + tyv*TANGENTIAL + uy*ALONG) * mag;
      }

      n.vx += (Math.random()-0.5)*NOISE;
      n.vy += (Math.random()-0.5)*NOISE;

      n.vx *= DAMP; n.vy *= DAMP;
      n.x  += n.vx; n.y  += n.vy;
    }

    // Base grid (draw only when moving)
    if(DRAW_BASE_GRID){
      ctx.lineWidth = (dpr>1?0.6:0.8);
      ctx.strokeStyle = `rgba(${DOT_RGB},${BASE_GRID_ALPHA * gate})`;
      for(let j=0;j<rows;j++){
        for(let i=0;i<cols;i++){
          const id = j*cols + i;
          const a = nodes[id];
          if(i+BASE_GRID_STEP < cols){
            const b = nodes[id+BASE_GRID_STEP];
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          }
          if(j+BASE_GRID_STEP < rows){
            const b = nodes[id+BASE_GRID_STEP*cols];
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          }
        }
      }
    }

    // Dot clusters
    for(let n of nodes){
      for(let m of n.cluster){
        const px = n.x + m.ox*dpr;
        const py = n.y + m.oy*dpr;
        const r  = m.r * dpr*0.9;
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI*2);
        ctx.fillStyle = `rgba(${DOT_RGB},${DOT_ALPHA*gate})`;
        ctx.fill();
      }
    }

    // Links near cursor
    if(DRAW_LINKS){
      ctx.lineWidth = (dpr>1?0.9:1.1);
      for(let j=0;j<rows;j++){
        for(let i=0;i<cols;i++){
          const id = j*cols + i;
          const a = nodes[id];
          const dx = (a.x/dpr - cursor.x);
          const dy = (a.y/dpr - cursor.y);
          const d2 = dx*dx + dy*dy;
          if(d2 > link2) continue;
          const w = Math.exp(-d2/(2*link2));
          const alpha = LINK_ALPHA_BASE * gate * (0.7 + 0.3*w);
          ctx.strokeStyle = `rgba(${DOT_RGB},${alpha})`;

          if(i < cols-1){
            const b = nodes[id+1];
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          }
          if(j < rows-1){
            const b = nodes[id+cols];
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          }
        }
      }
    }

    // Group distortion
    updateCopyGroup(dt);

    requestAnimationFrame(step);
  }

  /* ---------- Input: explicit movement detection ---------- */
  window.addEventListener('pointermove', (e)=>{
    cursor.tx = e.clientX; cursor.ty = e.clientY;
    isMoving = true;
    if(idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(()=>{ isMoving = false; }, IDLE_AFTER_MS);
    activity = Math.min(1, activity + 0.14);
  }, {passive:true});

  window.addEventListener('pointerleave', ()=>{
    cursor.tx = cursor.ty = null;
    isMoving = false; // hide immediately when leaving viewport
  }, {passive:true});

  /* ---------- Init ---------- */
  window.addEventListener('resize', resize);
  resize();
  requestAnimationFrame(step);

  // Keep orb centered under the copy group
  (function keepOrb(){
    const orb=document.getElementById('orb'), hero=document.getElementById('home'), copy=document.getElementById('copyGroup');
    function center(){
      if(!orb||!copy||!hero) return;
      const r=copy.getBoundingClientRect(), h=hero.getBoundingClientRect();
      orb.style.left = (r.left + r.width/2 - h.left) + 'px';
      orb.style.top  = (r.top  + r.height/2 - h.top ) + 'px';
    }
    window.addEventListener('load', center);
    window.addEventListener('resize', () => requestAnimationFrame(center));
  })();
})();
</script>
