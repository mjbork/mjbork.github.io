<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ORJM</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Playfair+Display:ital,wght@1,600&display=swap" rel="stylesheet" />
<style>
  :root{ --bg:#fcfbf8; --fg:#111; --muted:#666; }
  *,*::before,*::after{ box-sizing:border-box; margin:0; padding:0; }
  html,body{ height:100%; }
  body{ font-family:'Inter',system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:var(--fg); overflow-x:hidden; }

  /* Nav */
  .nav{
    position:fixed; top:1.2rem; right:2.4rem; z-index:3;
    display:flex; gap:1.4rem; font-size:.78rem; font-weight:500; letter-spacing:.02em; text-transform:lowercase;
  }
  .nav a{ color:var(--fg); text-decoration:none; transition:opacity .2s; }
  .nav a:hover{ opacity:.7; }

  /* Hero */
  .hero{
    position:relative; z-index:1; min-height:100vh;
    display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; padding:0 2rem;
  }
  .hero h1{
    position:relative; z-index:2; font-size:clamp(2.4rem,6vw,4.2rem); font-weight:500; text-transform:lowercase;
  }
  .cursive{ font-family:'Playfair Display',serif; font-style:italic; display:inline-block; }
  .roles{ margin-top:.7rem; font-size:.95rem; color:var(--muted); max-width:45rem; text-wrap:balance; }
  .btn{
    margin-top:1.8rem; padding:.72rem 1.8rem; font-size:.9rem;
    border:1px solid var(--fg); border-radius:.34rem; color:var(--fg);
    text-decoration:none; text-transform:lowercase; display:inline-block; transition:background .2s,color .2s,transform .2s;
  }
  .btn:hover{ background:var(--fg); color:var(--bg); transform:translateY(-1px); }

  /* Footer */
  footer{ position:fixed; bottom:1.2rem; left:0; right:0; display:flex; justify-content:center; z-index:1; }
  .socials{ display:flex; gap:1.45rem; align-items:center; }
  .socials a{ color:#7a7a7a; display:inline-flex; transition:opacity .2s, transform .2s; }
  .socials a:hover{ opacity:.9; transform:scale(1.12) rotate(3deg); }
  .socials svg{ width:22px; height:22px; stroke:currentColor; fill:none; stroke-width:1.5; }

  /* Soft orb */
  .orb{
    position:absolute; z-index:1; left:50%; top:50%; translate:-50% -50%;
    width:min(60vw,660px); aspect-ratio:1/1; border-radius:50%;
    background: radial-gradient(closest-side, rgba(0,0,0,.06), rgba(0,0,0,.04) 35%, rgba(0,0,0,.02) 65%, rgba(0,0,0,0) 80%);
    filter:blur(.2px); pointer-events:none;
  }

  /* Mesh canvas */
  .fx-canvas{ position:fixed; inset:0; z-index:0; pointer-events:none; }

  /* Per-letter distortion hooks */
  #title .ch{ display:inline-block; will-change:transform, filter; }

  @media(max-width:640px){
    .nav{ right:1rem; gap:1rem; font-size:.72rem; }
    .roles{ font-size:.86rem; }
  }
</style>
</head>
<body>
  <canvas id="fx" class="fx-canvas" aria-hidden="true"></canvas>

  <nav class="nav" aria-label="Primary">
    <a href="about.html">about</a>
    <a href="campaigns.html">campaigns</a>
    <a href="reel.html">reel</a>
    <a href="contact.html">contact</a>
  </nav>

  <section class="hero" id="home">
    <div class="orb" id="orb" aria-hidden="true"></div>

    <!-- Title letters split into spans so we can distort per-letter -->
    <h1 id="title" aria-label="orjm"><span class="cursive">
      <span class="ch">o</span><span class="ch">r</span><span class="ch">j</span><span class="ch">m</span>
    </span></h1>

    <p class="roles">strategist · ai-driven video · brand consultant</p>

    <!-- Leave "learn more" UNDISTORTED now -->
    <a id="learn" class="btn" href="learn-more.html" aria-label="learn more">learn more</a>
  </section>

  <footer>
    <div class="socials">
      <a aria-label="YouTube" href="#"><svg viewBox="0 0 24 24"><path d="M22.54 6.42a2.78 2.78 0 0 0-1.95-1.96C18.88 4 12 4 12 4s-6.88 0-8.59.46a2.78 2.78 0 0 0-1.95 1.96A29.94 29.94 0 0 0 1 12a29.94 29.94 0 0 0 .46 5.58 2.78 2.78 0 0 0 1.95 1.96C5.12 20 12 20 12 20s6.88 0 8.59-.46a2.78 2.78 0 0 0 1.95-1.96A29.94 29.94 0 0 0 23 12a29.94 29.94 0 0 0-.46-5.58Z"/><polygon points="10 15 15 12 10 9 10 15"/></svg></a>
      <a aria-label="Discord" href="#"><svg viewBox="0 0 24 24"><path d="M20.317 4.369A19.791 19.791 0 0 0 15.559 3c-.23.397-.48.92-.658 1.333-1.988-.297-3.962-.297-5.93 0-.18-.426-.437-.936-.666-1.333A19.736 19.736 0 0 0 3.68 4.369 21.639 21.639 0 0 0 1 18.968a19.85 19.85 0 0 0 5.993 2.999c.481-.651.908-1.342 1.291-2.067a13.05 13.05 0 0 1-2.033-.974c.17-.126.334-.258.492-.396a14.75 14.75 0 0 0 12.512 0c.16.146.323.278.492.404-.65.384-1.33.705-2.033.964.383.725.81 1.416 1.29 2.066A19.788 19.788 0 0 0 23 18.969a21.635 21.635 0 0 0-2.683-14.6Z"/></svg></a>
      <a aria-label="X" href="#"><svg viewBox="0 0 24 24"><path d="M4 4 20 20m0-16L4 20"/></svg></a>
      <a aria-label="LinkedIn" href="#"><svg viewBox="0 0 24 24"><path d="M3.94 3.5A2.44 2.44 0 0 0 1.5 5.94a2.44 2.44 0 0 0 2.44 2.44 2.44 2.44 0 0 0 2.44-2.44A2.44 2.44 0 0 0 3.94 3.5Zm.06 3.74H1.48v13.7h2.52v-13.7Zm6.85-4.94c-1.57 0-2.53.86-2.96 1.55v-1.34H5v13.7h2.41v-7.83c0-.41.03-.83.15-1.12.38-.92 1.25-1.88 2.71-1.88 1.91 0 2.67 1.41 2.67 3.48v7.35h2.42v-7.91c0-4.11-2.18-6.04-5.09-6.04z"/></svg></a>
    </div>
  </footer>

<script>
/* =========================================================
   CHAIN-LINK made of CLUSTERS (mini-dots) — GRAY
   - Smooth fade-out at rest
   - "orjm" distorts smoothly (per-letter easing)
   - "learn more" stays stable (no distortion)
========================================================= */
(function(){
  const canvas = document.getElementById('fx');
  const ctx = canvas.getContext('2d');
  if(!ctx) return;

  /* ---------- Visual (gray mesh) ---------- */
  const DOT_RGB   = '150,150,150';   // subtle gray
  const GAP       = 46;              // grid spacing
  const CLUSTER_N = 8;               // micro-dots per node
  const CLUSTER_R = 5;               // cluster radius (CSS px)
  const MICRO_R   = [0.35, 0.9];     // micro-dot radius (CSS px)
  const DOT_ALPHA = 0.23;            // base opacity (scaled by activity)

  const DRAW_LINKS      = true;      // faint connections near cursor
  const LINK_ALPHA_BASE = 0.06;
  const LINK_RADIUS     = 210;       // px

  /* ---------- Physics ---------- */
  const DAMP   = 0.974;  // smoother settle
  const SPRING = 0.008;  // soft return to origin
  const NOISE  = 0.006;  // tiny shimmer

  // Cursor influence (chain-link push)
  const INFL_R    = 190;  // px
  const PUSH      = 0.30; // strength
  const RADIAL    = 0.60; // radial away
  const TANGENTIAL= 0.10; // slight curl
  const ALONG     = 0.16; // tug along motion

  /* ---------- Visibility (smooth fade) ---------- */
  let activity = 0;              // 0..1
  const MOVE_BOOST     = 0.16;   // bump per motion
  const SPEED_GAIN     = 0.55;   // extra from speed
  const ACTIVITY_DECAY = 0.0075; // slower decay → smoother fade-out

  /* ---------- State ---------- */
  let dpr = Math.min(window.devicePixelRatio || 1, 2);
  let W=0, H=0, cols=0, rows=0;
  const nodes = [];

  const cursor = { tx:null, ty:null, x:null, y:null, px:0, py:0, vx:0, vy:0 };
  const EASE = 0.14;

  // Distortion target: title only (smooth per-letter easing)
  const titleLetters = Array.from(document.querySelectorAll('#title .ch'));
  const letterState = titleLetters.map(() => ({ x:0, y:0, bx:0, by:0 })); // current & target offsets

  function resize(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = canvas.width  = Math.floor(innerWidth  * dpr);
    H = canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';

    nodes.length = 0;
    cols = Math.ceil(innerWidth / GAP) + 2;
    rows = Math.ceil(innerHeight/ GAP) + 2;

    for(let j=0;j<rows;j++){
      for(let i=0;i<cols;i++){
        const ox_css = i*GAP + (j%2 ? GAP/2 : 0); // slight stagger
        const oy_css = j*GAP + 20;
        const x = ox_css * dpr, y = oy_css * dpr;

        const cluster = [];
        for(let k=0;k<CLUSTER_N;k++){
          const a = (k/CLUSTER_N)*Math.PI*2 + Math.random()*0.6;
          const rr = (CLUSTER_R*(0.55 + Math.random()*0.45));
          cluster.push({
            ox: Math.cos(a)*rr,
            oy: Math.sin(a)*rr,
            r:  (MICRO_R[0] + Math.random()*(MICRO_R[1]-MICRO_R[0]))
          });
        }

        nodes.push({ x, y, ox:x, oy:y, vx:0, vy:0, cluster });
      }
    }
  }

  function distortTitle(){
    // set target offsets (bx/by) based on cursor proximity, then ease x/y toward bx/by
    const cx = cursor.x, cy = cursor.y;
    const maxShiftPx = 9;     // softer than before
    const radiusPx   = 220;
    const r2 = radiusPx*radiusPx;

    for(let idx=0; idx<titleLetters.length; idx++){
      const el = titleLetters[idx];
      const st = letterState[idx];

      if(cx == null){
        st.bx = 0; st.by = 0;
      }else{
        const b = el.getBoundingClientRect();
        const ex = (b.left + b.width/2);
        const ey = (b.top  + b.height/2);
        const dx = ex - cx;
        const dy = ey - cy;
        const d2 = dx*dx + dy*dy;
        if(d2 > r2){
          st.bx = 0; st.by = 0;
        }else{
          const fall = Math.exp(-d2/(2*r2));
          const vmag = Math.hypot(cursor.vx, cursor.vy) || 1e-6;
          const ux = cursor.vx/vmag, uy = cursor.vy/vmag;
          const rlen = Math.max(1e-6, Math.hypot(dx,dy));
          const rx = dx/rlen, ry = dy/rlen;

          // target shift: mostly radial, slightly along motion
          st.bx = (rx*0.72 + ux*0.28) * maxShiftPx * fall * activity;
          st.by = (ry*0.72 + uy*0.28) * maxShiftPx * fall * activity;
        }
      }

      // smooth easing toward target (very soft)
      const ease = 0.14;
      st.x += (st.bx - st.x) * ease;
      st.y += (st.by - st.y) * ease;

      // apply transform + a tiny blur tied to magnitude
      const mag = Math.min(1, Math.hypot(st.x, st.y) / 12);
      el.style.transform = `translate3d(${st.x}px, ${st.y}px, 0)`;
      el.style.filter = mag > 0.02 ? `blur(${0.6*mag}px) contrast(${1 + 0.08*mag})` : 'none';
    }
  }

  function step(){
    // Smooth cursor + velocity
    if(cursor.tx != null){
      if(cursor.x == null){ cursor.x = cursor.tx; cursor.y = cursor.ty; cursor.px = cursor.x; cursor.py = cursor.y; }
      cursor.x += (cursor.tx - cursor.x) * EASE;
      cursor.y += (cursor.ty - cursor.y) * EASE;
      cursor.vx = (cursor.x - cursor.px);
      cursor.vy = (cursor.y - cursor.py);
      const vmag = Math.hypot(cursor.vx, cursor.vy);
      activity = Math.min(1, activity + MOVE_BOOST + SPEED_GAIN * Math.min(1, vmag/28));
      cursor.px = cursor.x; cursor.py = cursor.y;
    }
    activity = Math.max(0, activity - ACTIVITY_DECAY);

    ctx.clearRect(0,0,W,H);

    // Precompute
    const gate = Math.pow(activity, 1.2); // smooth fade
    const infl2 = INFL_R*INFL_R;
    const link2 = LINK_RADIUS*LINK_RADIUS;

    const vmag = Math.hypot(cursor.vx, cursor.vy) || 1e-6;
    const ux = cursor.vx/vmag, uy = cursor.vy/vmag; // along motion
    const tx = -uy, ty = ux;                        // tangent

    // Update nodes
    for(let n of nodes){
      // Spring to origin
      n.vx += (n.ox - n.x) * SPRING;
      n.vy += (n.oy - n.y) * SPRING;

      // Displacement from cursor (chain-link push)
      if(cursor.x != null && gate > 0){
        const dx = (n.x/dpr - cursor.x);
        const dy = (n.y/dpr - cursor.y);
        const d2 = dx*dx + dy*dy;
        if(d2 < infl2){
          const fall = Math.exp(-d2/(2*infl2));
          const rlen = Math.max(1e-6, Math.hypot(dx,dy));
          const rx = dx/rlen, ry = dy/rlen;
          const mag = PUSH * fall * dpr;
          n.vx += (rx*RADIAL + tx*TANGENTIAL + ux*ALONG) * mag;
          n.vy += (ry*RADIAL + ty*TANGENTIAL + uy*ALONG) * mag;
        }
      }

      // Subtle shimmer
      n.vx += (Math.random()-0.5)*NOISE;
      n.vy += (Math.random()-0.5)*NOISE;

      // Integrate
      n.vx *= DAMP; n.vy *= DAMP;
      n.x  += n.vx; n.y  += n.vy;
    }

    // Draw clusters (mini-dots)
    if(gate > 0.002){
      for(let n of nodes){
        for(let m of n.cluster){
          const px = n.x + m.ox*dpr;
          const py = n.y + m.oy*dpr;
          const r  = m.r * dpr*0.9;
          ctx.beginPath();
          ctx.arc(px, py, r, 0, Math.PI*2);
          ctx.fillStyle = `rgba(${DOT_RGB},${DOT_ALPHA*gate})`;
          ctx.fill();
        }
      }
    }

    // Optional faint links near cursor (to sell mesh)
    if(DRAW_LINKS && gate > 0.002 && cursor.x != null){
      ctx.lineWidth = (dpr>1?0.75:1);
      for(let j=0;j<rows;j++){
        for(let i=0;i<cols;i++){
          const idx = j*cols + i;
          const a = nodes[idx];
          const dx = (a.x/dpr - cursor.x);
          const dy = (a.y/dpr - cursor.y);
          const d2 = dx*dx + dy*dy;
          if(d2 > link2) continue;
          const w = Math.exp(-d2/(2*link2));
          const alpha = LINK_ALPHA_BASE * gate * (0.6 + 0.4*w);
          ctx.strokeStyle = `rgba(${DOT_RGB},${alpha})`;

          if(i < cols-1){
            const b = nodes[idx+1];
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          }
          if(j < rows-1){
            const b = nodes[idx+cols];
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          }
        }
      }
    }

    // Smooth title distortion (only ORJM)
    distortTitle();

    requestAnimationFrame(step);
  }

  // Input
  window.addEventListener('mousemove', (e)=>{
    cursor.tx = e.clientX; cursor.ty = e.clientY;
    activity = Math.min(1, activity + 0.12); // snappy fade-in
  }, {passive:true});
  window.addEventListener('mouseleave', ()=>{
    cursor.tx = cursor.ty = null; // graceful fade out
  }, {passive:true});

  // Init
  window.addEventListener('resize', resize);
  resize();
  requestAnimationFrame(step);

  // Keep orb centered under the wordmark
  (function keepOrb(){
    const orb=document.getElementById('orb'), title=document.getElementById('title'), hero=document.getElementById('home');
    function center(){
      if(!orb||!title||!hero) return;
      const r=title.getBoundingClientRect(), h=hero.getBoundingClientRect();
      orb.style.left = (r.left + r.width/2 - h.left) + 'px';
      orb.style.top  = (r.top  + r.height/2 - h.top ) + 'px';
    }
    window.addEventListener('load', center);
    window.addEventListener('resize', () => requestAnimationFrame(center));
  })();
})();
</script>
</body>
</html>
