<script>
/* =========================================================
   MICRO-DOTS: HOOK & DRAG — VISIBLE ONLY WHEN MOVING
   - Dots fade in with motion, fade out when idle
   - Hook nearest dot and drag it; neighbors follow
   ========================================================= */
(function(){
  const canvas = document.getElementById('fx');
  const ctx = canvas.getContext('2d');
  let dpr = Math.min(window.devicePixelRatio || 1, 2);
  let W, H, dots = [];

  /* --------- Visual + layout --------- */
  let gap = 52;                 // spacing (bigger = more dispersed)
  let baseAlpha = 0.22;         // baseline visibility (will be scaled by activity)
  const color = '191,185,174';  // warm grey
  const RMIN = 1.0, RMAX = 1.6; // dot radius range (CSS px)

  /* --------- Physics --------- */
  const DAMP   = 0.93;   // viscosity
  const SPRING = 0.010;  // return to origin
  const NOISE  = 0.02;   // tiny organic jitter

  // Hook behavior
  const FOLLOW_RADIUS   = 190;  // how far neighbors feel the leader (px)
  const FOLLOW_STRENGTH = 0.11; // neighbor pull strength
  const LEADER_STRENGTH = 0.44; // leader snaps to cursor
  const HOOK_RADIUS     = 110;  // max distance to hook a leader (px)

  /* --------- Visibility (motion-activated) --------- */
  let activity = 0;            // 0..1 (drives opacity & hooking)
  const MOVE_BOOST = 0.28;     // how much a move bumps activity
  const SPEED_GAIN = 0.6;      // extra boost from fast motion
  const ACTIVITY_DECAY = 0.015;// per frame decay (lower = lingers longer)
  const ACTIVE_EPS = 0.03;     // below this, treat as idle

  /* --------- Smoothed cursor --------- */
  const cursor = { tx:-1e9, ty:-1e9, x:-1e9, y:-1e9, px:-1e9, py:-1e9, vx:0, vy:0 };
  const EASE = 0.18;

  let leader = -1;

  function resize(){
    W = canvas.width  = Math.floor(innerWidth  * dpr);
    H = canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    buildDots();
  }

  function buildDots(){
    dots = [];
    const gx = Math.ceil(innerWidth  / gap) + 2;
    const gy = Math.ceil(innerHeight / gap) + 2;
    for(let j=0;j<gy;j++){
      for(let i=0;i<gx;i++){
        const ox = (i*gap + (j%2 ? gap/2 : 0));
        const oy = (j*gap + 20);
        const x = ox * dpr, y = oy * dpr;
        const r = (RMIN + Math.random()*(RMAX-RMIN)) * dpr;
        dots.push({ x, y, ox:x, oy:y, vx:0, vy:0, r });
      }
    }
  }

  let lastT = 0;
  function step(ts){
    if(!lastT) lastT = ts;
    const dt = Math.min(32, ts - lastT); // clamp for stability
    lastT = ts;

    // Smooth cursor
    if(!isFinite(cursor.x)){ cursor.x = cursor.tx; cursor.y = cursor.ty; cursor.px = cursor.x; cursor.py = cursor.y; }
    cursor.x += (cursor.tx - cursor.x) * EASE;
    cursor.y += (cursor.ty - cursor.y) * EASE;

    // Compute smoothed velocity (for activity boost)
    const vx = (cursor.x - cursor.px); const vy = (cursor.y - cursor.py);
    const vmag = Math.hypot(vx, vy);
    cursor.px = cursor.x; cursor.py = cursor.y;

    // Update activity: boost from motion, then decay
    activity = Math.max(0, Math.min(1, activity + MOVE_BOOST + SPEED_GAIN * Math.min(1, vmag/28)));
    activity = Math.max(0, activity - ACTIVITY_DECAY);

    // Clear frame
    ctx.clearRect(0,0,W,H);

    // Choose/update leader only if active
    if(activity > ACTIVE_EPS && isFinite(cursor.tx)){
      let best=-1, bestD2=HOOK_RADIUS*HOOK_RADIUS;
      for(let i=0;i<dots.length;i++){
        const p = dots[i];
        const dx = p.x/dpr - cursor.x, dy = p.y/dpr - cursor.y;
        const d2 = dx*dx + dy*dy;
        if(d2 < bestD2){ bestD2 = d2; best = i; }
      }
      leader = best;
    } else {
      leader = -1;
    }

    // Pull leader toward cursor (when active)
    let lx=0, ly=0;
    if(leader >= 0){
      const L = dots[leader];
      lx = L.x; ly = L.y;
      L.vx += (cursor.x*dpr - L.x) * LEADER_STRENGTH;
      L.vy += (cursor.y*dpr - L.y) * LEADER_STRENGTH;
    }

    // Animate and draw dots
    for(const p of dots){
      // spring back to origin
      p.vx += (p.ox - p.x) * SPRING;
      p.vy += (p.oy - p.y) * SPRING;

      // neighbors follow the leader when active
      if(leader >= 0 && p !== dots[leader]){
        const dx = (lx - p.x), dy = (ly - p.y);
        const dist = Math.hypot(dx, dy);
        if(dist < FOLLOW_RADIUS*dpr){
          const w = (1 - dist/(FOLLOW_RADIUS*dpr));
          p.vx += dx * (FOLLOW_STRENGTH * w);
          p.vy += dy * (FOLLOW_STRENGTH * w);
          // gentle tangential component for smooth arc
          p.vx += (-dy) * 0.0006 * w;
          p.vy += ( dx) * 0.0006 * w;
        }
      }

      // organic jitter
      p.vx += (Math.random()-0.5) * NOISE;
      p.vy += (Math.random()-0.5) * NOISE;

      // integrate
      p.vx *= DAMP; p.vy *= DAMP;
      p.x  += p.vx; p.y  += p.vy;

      // draw — opacity scaled by activity; a bit brighter when moving faster
      const speed = Math.min(1, Math.hypot(p.vx, p.vy) / (1.0*dpr));
      const a = (baseAlpha + speed*0.18) * activity;   // <- activity gates visibility
      if(a > 0.004){ // skip near-zero to save fill calls
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fillStyle = `rgba(${color},${a})`;
        ctx.fill();
      }
    }

    requestAnimationFrame(step);
  }

  // Mouse → update target, and give an immediate activity kick per event
  window.addEventListener('mousemove', (e) => {
    cursor.tx = e.clientX;
    cursor.ty = e.clientY;
    activity = Math.min(1, activity + 0.15); // instant nudge so dots appear promptly
  }, {passive:true});

  window.addEventListener('mouseleave', () => {
    cursor.tx = cursor.ty = -1e9;
  }, {passive:true});

  // Init
  window.addEventListener('resize', resize);
  resize();
  requestAnimationFrame(step);

  /* ========== Quick knobs ==========
     gap: 48–58 (density)
     baseAlpha: 0.18–0.28 (overall dot strength)
     MOVE_BOOST / SPEED_GAIN: how quickly dots appear with motion
     ACTIVITY_DECAY: 0.012–0.02 (how fast they fade at rest)
     HOOK_RADIUS / LEADER_STRENGTH / FOLLOW_*: hook feel
  */
})();
</script>
