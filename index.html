<script>
// ==========================================
// MICRO-DOTS: Hook & Drag — Only visible when moving
// (no lingering at rest; smoother net movement)
// ==========================================
(function(){
  const canvas = document.getElementById('fx');
  const ctx = canvas.getContext('2d');
  if(!ctx) return;

  let dpr = Math.min(window.devicePixelRatio || 1, 2);
  let W=0, H=0, dots=[];

  // ------- Visual -------
  const gap = 52;                 // spacing (bigger = more dispersed)
  const baseAlpha = 0.22;         // baseline (is gated by activity)
  const color = '191,185,174';    // warm grey; try '200,40,40' for a red net
  const RMIN = 1.0, RMAX = 1.6;   // dot radius (CSS px)

  // ------- Physics (smoothed) -------
  const DAMP   = 0.965;  // higher = smoother, less bounce (was ~0.93)
  const SPRING = 0.008;  // softer return to origin (was 0.010)
  const NOISE  = 0.010;  // less jitter (was 0.02)

  // Hook & follow
  const FOLLOW_RADIUS   = 190;
  const FOLLOW_STRENGTH = 0.095;  // gentler pull
  const LEADER_STRENGTH = 0.36;   // softer snap-to-cursor
  const HOOK_RADIUS     = 110;

  // ------- Visibility control -------
  let activity = 0;                     // 0..1
  const MOVE_BOOST = 0.22;              // base bump per event
  const SPEED_GAIN = 0.55;              // extra from speed
  const ACTIVITY_DECAY = 0.028;         // fades quickly
  const ACTIVE_EPS = 0.05;              // under this = idle
  const IDLE_ZERO_MS = 90;              // hard cutoff: no draw if idle this long

  // Smoothed cursor
  const cursor = { tx:null, ty:null, x:null, y:null, px:0, py:0 };
  const EASE = 0.12;                    // gentler pointer smoothing
  let lastMoveTs = 0;

  let leader = -1;
  let lastT = 0;

  function resize(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = canvas.width  = Math.floor(innerWidth  * dpr);
    H = canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    buildDots();
  }

  function buildDots(){
    dots = [];
    const gx = Math.ceil(innerWidth  / gap) + 2;
    const gy = Math.ceil(innerHeight / gap) + 2;
    for(let j=0;j<gy;j++){
      for(let i=0;i<gx;i++){
        const ox = (i*gap + (j%2 ? gap/2 : 0));
        const oy = (j*gap + 20);
        const x = ox * dpr, y = oy * dpr;
        const r = (RMIN + Math.random()*(RMAX-RMIN)) * dpr;
        dots.push({ x, y, ox:x, oy:y, vx:0, vy:0, r });
      }
    }
  }

  function step(ts){
    if(!lastT) lastT = ts;
    const dt = Math.max(1, Math.min(32, ts - lastT));
    lastT = ts;

    // Cursor smoothing
    if(cursor.tx != null){
      if(cursor.x == null){ cursor.x = cursor.tx; cursor.y = cursor.ty; cursor.px = cursor.x; cursor.py = cursor.y; }
      cursor.x += (cursor.tx - cursor.x) * EASE;
      cursor.y += (cursor.ty - cursor.y) * EASE;
      const vx = (cursor.x - cursor.px);
      const vy = (cursor.y - cursor.py);
      const vmag = Math.hypot(vx, vy);
      cursor.px = cursor.x; cursor.py = cursor.y;

      // Boost activity when moving, then decay
      activity = Math.min(1, activity + MOVE_BOOST + SPEED_GAIN * Math.min(1, vmag/28));
    }
    activity = Math.max(0, activity - ACTIVITY_DECAY);

    // Hard idle cutoff (no drawing whatsoever)
    const now = performance.now();
    const idleTooLong = (now - lastMoveTs) > IDLE_ZERO_MS || cursor.tx == null;
    if(idleTooLong){ activity = 0; }

    ctx.clearRect(0,0,W,H);

    // Pick leader only if visibly active
    if(activity > ACTIVE_EPS && cursor.x != null){
      let best=-1, bestD2=HOOK_RADIUS*HOOK_RADIUS;
      for(let i=0;i<dots.length;i++){
        const p = dots[i];
        const dx = p.x/dpr - cursor.x, dy = p.y/dpr - cursor.y;
        const d2 = dx*dx + dy*dy;
        if(d2 < bestD2){ bestD2 = d2; best = i; }
      }
      leader = best;
    } else {
      leader = -1;
    }

    // Pull leader toward cursor
    let lx=0, ly=0;
    if(leader >= 0){
      const L = dots[leader];
      lx = L.x; ly = L.y;
      L.vx += (cursor.x*dpr - L.x) * LEADER_STRENGTH;
      L.vy += (cursor.y*dpr - L.y) * LEADER_STRENGTH;
    }

    // Draw only if active (prevents any linger)
    if(activity > 0){
      // Nonlinear gating (squash faint leftovers)
      const gate = Math.pow(activity, 1.6);

      for(let i=0;i<dots.length;i++){
        const p = dots[i];

        // spring to origin (soft)
        p.vx += (p.ox - p.x) * SPRING;
        p.vy += (p.oy - p.y) * SPRING;

        // follower pull (smooth)
        if(leader >= 0 && i !== leader){
          const dx = (lx - p.x), dy = (ly - p.y);
          const dist = Math.hypot(dx, dy);
          if(dist < FOLLOW_RADIUS*dpr){
            const w = (1 - dist/(FOLLOW_RADIUS*dpr));
            p.vx += dx * (FOLLOW_STRENGTH * w);
            p.vy += dy * (FOLLOW_STRENGTH * w);
            // slight tangential for flow
            p.vx += (-dy) * 0.00045 * w;
            p.vy += ( dx) * 0.00045 * w;
          }
        }

        // tiny organic jitter
        p.vx += (Math.random()-0.5) * NOISE;
        p.vy += (Math.random()-0.5) * NOISE;

        // integrate (high damping → smooth)
        p.vx *= DAMP; p.vy *= DAMP;
        p.x  += p.vx; p.y  += p.vy;

        // alpha
        const speed = Math.min(1, Math.hypot(p.vx, p.vy) / (1.0*dpr));
        const a = (baseAlpha + speed*0.12) * gate;  // less speed pop for smoothness
        if(a > 0.01){
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fillStyle = `rgba(${color},${a})`;
          ctx.fill();
        }
      }
    }

    requestAnimationFrame(step);
  }

  // Mouse events
  window.addEventListener('mousemove', (e) => {
    if(cursor.tx == null){ activity = 1; }      // first reveal
    cursor.tx = e.clientX; cursor.ty = e.clientY;
    lastMoveTs = performance.now();
    activity = Math.min(1, activity + 0.18);    // snappy fade-in
  }, {passive:true});

  window.addEventListener('mouseleave', () => {
    cursor.tx = cursor.ty = null;
    activity = 0;                                // instant vanish
  }, {passive:true});

  // Start
  window.addEventListener('resize', resize);
  resize();
  requestAnimationFrame(step);
})();
</script>
