<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ORJM</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Playfair+Display:ital,wght@1,600&display=swap" rel="stylesheet" />
  <style>
    :root{
      --bg:#fcfbf8;  /* off-white */
      --fg:#111111;  /* text */
      --muted:#666666;
    }
    *,*::before,*::after{ box-sizing:border-box; margin:0; padding:0; }
    html,body{ height:100%; }
    body{
      font-family:'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:var(--bg);
      color:var(--fg);
      overflow-x:hidden;
    }

    /* Top-right nav */
    .nav{
      position:fixed; top:1.2rem; right:2.4rem; z-index:3;
      display:flex; gap:1.4rem; font-size:.78rem; font-weight:500; letter-spacing:.02em;
      text-transform:lowercase;
    }
    .nav a{ color:var(--fg); text-decoration:none; transition:opacity .2s; }
    .nav a:hover{ opacity:.7; }

    /* Hero */
    .hero{
      position:relative; z-index:1; min-height:100vh;
      display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center;
      padding:0 2rem;
    }
    .hero h1{
      position:relative; z-index:2;
      font-size:clamp(2.1rem,5vw,3.8rem);
      font-weight:500; text-transform:lowercase;
    }
    .cursive{ font-family:'Playfair Display',serif; font-style:italic; }

    .roles{ margin-top:.7rem; font-size:.95rem; color:var(--muted); max-width:45rem; text-wrap:balance; }
    .btn{
      margin-top:1.8rem; padding:.72rem 1.8rem; font-size:.85rem;
      border:1px solid var(--fg); border-radius:.34rem; color:var(--fg);
      text-decoration:none; text-transform:lowercase; display:inline-block;
      transition:background .2s,color .2s,transform .2s;
    }
    .btn:hover{ background:var(--fg); color:var(--bg); transform:translateY(-1px); }

    footer{ position:fixed; bottom:1.2rem; left:0; right:0; display:flex; justify-content:center; z-index:1; }
    .socials{ display:flex; gap:1.45rem; align-items:center; }
    .socials a{ color:#7a7a7a; display:inline-flex; transition:opacity .2s, transform .2s; }
    .socials a:hover{ opacity:.9; transform:scale(1.12) rotate(3deg); }
    .socials svg{ width:22px; height:22px; stroke:currentColor; fill:none; stroke-width:1.5; }

    /* Gentle orb behind the wordmark */
    .orb{
      position:absolute; z-index:1;
      left:50%; top:50%; translate:-50% -50%;
      width:min(60vw, 660px); aspect-ratio:1/1; border-radius:50%;
      background:
        radial-gradient(closest-side,
          rgba(0,0,0,.06),
          rgba(0,0,0,.04) 35%,
          rgba(0,0,0,.02) 65%,
          rgba(0,0,0,0) 80%);
      filter:blur(.2px);
      pointer-events:none;
    }

    /* Micro-dot canvas */
    .fx-canvas{
      position:fixed; inset:0; z-index:0; pointer-events:none;
    }

    @media(max-width:640px){
      .nav{ right:1rem; gap:1rem; font-size:.72rem; }
      .roles{ font-size:.86rem; }
    }
  </style>
</head>
<body>
  <!-- Micro-dots field -->
  <canvas id="fx" class="fx-canvas" aria-hidden="true"></canvas>

  <!-- Nav -->
  <nav class="nav" aria-label="Primary">
    <a href="about.html">about</a>
    <a href="campaigns.html">campaigns</a>
    <a href="reel.html">reel</a>
    <a href="contact.html">contact</a>
  </nav>

  <!-- Hero -->
  <section class="hero" id="home">
    <div class="orb" id="orb" aria-hidden="true"></div>
    <h1 id="title"><span class="cursive">orjm</span></h1>
    <p class="roles">strategist · ai-driven video · brand consultant</p>
    <a class="btn" href="learn-more.html">learn more</a>
  </section>

  <footer>
    <div class="socials">
      <a aria-label="YouTube" href="#"><svg viewBox="0 0 24 24"><path d="M22.54 6.42a2.78 2.78 0 0 0-1.95-1.96C18.88 4 12 4 12 4s-6.88 0-8.59.46a2.78 2.78 0 0 0-1.95 1.96A29.94 29.94 0 0 0 1 12a29.94 29.94 0 0 0 .46 5.58 2.78 2.78 0 0 0 1.95 1.96C5.12 20 12 20 12 20s6.88 0 8.59-.46a2.78 2.78 0 0 0 1.95-1.96A29.94 29.94 0 0 0 23 12a29.94 29.94 0 0 0-.46-5.58Z"/><polygon points="10 15 15 12 10 9 10 15"/></svg></a>
      <a aria-label="Discord" href="#"><svg viewBox="0 0 24 24"><path d="M20.317 4.369A19.791 19.791 0 0 0 15.559 3c-.23.397-.48.92-.658 1.333-1.988-.297-3.962-.297-5.93 0-.18-.426-.437-.936-.666-1.333A19.736 19.736 0 0 0 3.68 4.369 21.639 21.639 0 0 0 1 18.968a19.85 19.85 0 0 0 5.993 2.999c.481-.651.908-1.342 1.291-2.067a13.05 13.05 0 0 1-2.033-.974c.17-.126.334-.258.492-.396a14.75 14.75 0 0 0 12.512 0c.16.146.323.278.492.404-.65.384-1.33.705-2.033.964.383.725.81 1.416 1.29 2.066A19.788 19.788 0 0 0 23 18.969a21.635 21.635 0 0 0-2.683-14.6Z"/></svg></a>
      <a aria-label="X" href="#"><svg viewBox="0 0 24 24"><path d="M4 4 20 20m0-16L4 20"/></svg></a>
      <a aria-label="LinkedIn" href="#"><svg viewBox="0 0 24 24"><path d="M3.94 3.5A2.44 2.44 0 0 0 1.5 5.94a2.44 2.44 0 0 0 2.44 2.44 2.44 2.44 0 0 0 2.44-2.44A2.44 2.44 0 0 0 3.94 3.5Zm.06 3.74H1.48v13.7h2.52v-13.7Zm6.85-4.94c-1.57 0-2.53.86-2.96 1.55v-1.34H5v13.7h2.41v-7.83c0-.41.03-.83.15-1.12.38-.92 1.25-1.88 2.71-1.88 1.91 0 2.67 1.41 2.67 3.48v7.35h2.42v-7.91c0-4.11-2.18-6.04-5.09-6.04z"/></svg></a>
    </div>
  </footer>

  <script>
    /* =========================================================
       MICRO-DOTS: hook & drag + IDLE ORGANIC SHAPES
       - While moving: hooks nearest dot, nearby dots follow (smooth tail)
       - When idle: local dots assemble into a random organic silhouette
         (leaf, bird, face profile, tree canopy) near the cursor
       ========================================================= */
    (function(){
      const canvas = document.getElementById('fx');
      const ctx = canvas.getContext('2d');
      let dpr = Math.min(window.devicePixelRatio || 1, 2);
      let W, H, dots = [];

      /* ---------- Tuning ---------- */
      let gap = 52;                      // spacing (larger = more dispersed)
      let baseAlpha = 0.22;              // visibility baseline (0.18–0.28)
      const color = '191,185,174';       // warm grey RGB
      const RMIN = 1.1, RMAX = 1.8;      // dot radius range (CSS px)

      // Motion (hook & drag)
      const DAMP   = 0.93;               // viscosity
      const SPRING = 0.010;              // return to origin
      const NOISE  = 0.03;               // tiny wander
      const FOLLOW_RADIUS   = 190;       // follower influence
      const FOLLOW_STRENGTH = 0.11;      // follower pull
      const LEADER_STRENGTH = 0.42;      // leader snaps to cursor
      const HOOK_RADIUS     = 100;       // proximity to hook

      // Idle → shape assembly
      const IDLE_MS     = 1200;          // time without movement to trigger
      const SHAPE_SIZE  = [140, 220];    // px range for shapes (min, max)
      const SHAPE_PULL  = 0.25;          // spring toward target when assembling
      const SHAPE_BREATHE = 0.015;       // subtle breathing of shape
      const ASSEMBLY_RADIUS = 240;       // radius around cursor to recruit dots

      // Smoothed cursor
      const cursor = { tx:-1e9, ty:-1e9, x:-1e9, y:-1e9 };
      const EASE = 0.18;

      // Idle tracking
      let lastMove = performance.now();
      let assembling = false;
      let assigned = []; // list of indices of dots assigned to shape
      let targets  = []; // [{x,y}] same length as assigned
      let leader = -1;

      function resize(){
        W = canvas.width  = Math.floor(innerWidth  * dpr);
        H = canvas.height = Math.floor(innerHeight * dpr);
        canvas.style.width  = innerWidth + 'px';
        canvas.style.height = innerHeight + 'px';
        buildDots();
      }

      function buildDots(){
        dots = [];
        const gx = Math.ceil(innerWidth / gap) + 2;
        const gy = Math.ceil(innerHeight / gap) + 2;
        for(let j=0;j<gy;j++){
          for(let i=0;i<gx;i++){
            const ox = (i*gap + (j%2 ? gap/2 : 0));
            const oy = (j*gap + 20);
            const x = ox * dpr, y = oy * dpr;
            const r = (RMIN + Math.random()*(RMAX-RMIN)) * dpr;
            dots.push({ x, y, ox:x, oy:y, vx:0, vy:0, r, tx:NaN, ty:NaN });
          }
        }
      }

      /* ---------- Shape generators (normalized to [-1,1]) ---------- */
      function genLeaf(n){
        const pts = [];
        for(let i=0;i<n;i++){
          const t = i/n * Math.PI*2;
          const r = 0.75*(1 - 0.55*Math.sin(t)); // cardioid-ish
          const x = r*Math.cos(t);
          const y = 1.2*r*Math.sin(t);
          pts.push([x,y]);
        }
        // central vein
        for(let i=0;i<n*0.3;i++){
          const s = i/(n*0.3);
          pts.push([0, (s*2-1)*0.9]);
        }
        return pts;
      }
      function genBird(n){
        // soaring bird: two wings (swooshes) + small body
        const pts = [];
        for(let i=0;i<n;i++){
          const u = i/n;
          const t = (u*2-1);
          const y = 0.45*Math.sin(Math.PI*u)*(1-0.2*Math.abs(t));
          const x = t*1.2;
          pts.push([x,y]);
          pts.push([x,-y*0.85]);
        }
        for(let i=0;i<n*0.2;i++){ // body blob
          const a = (i/(n*0.2))*Math.PI*2;
          pts.push([0.0 + 0.18*Math.cos(a), 0.0 + 0.22*Math.sin(a)]);
        }
        return pts;
      }
      function genFace(n){
        // simple right-facing profile (forehead→nose→lips→chin→neck)
        const outline = [
          [0.1, -0.95],[ -0.2,-0.75],[ -0.28,-0.55],
          [ -0.18,-0.35],[ 0.05,-0.18], // cheek
          [ 0.25,-0.1],[ 0.22,-0.02],[ 0.26, 0.04], // lips
          [ 0.18, 0.22],[ 0.02, 0.38],[ -0.1, 0.55], // nose bridge/forehead
          [ -0.05, 0.78],[ 0.05,0.94],[ 0.1,0.98]
        ];
        // resample to n points
        const pts = [];
        for(let i=0;i<n;i++){
          const t = i/(n-1)*(outline.length-1);
          const i0 = Math.floor(t), i1 = Math.min(outline.length-1, i0+1);
          const a = t - i0;
          const x = outline[i0][0]*(1-a) + outline[i1][0]*a;
          const y = outline[i0][1]*(1-a) + outline[i1][1]*a;
          pts.push([x*1.1, y*1.1]);
        }
        // head blob to fill
        for(let i=0;i<n*0.4;i++){
          const a = (i/(n*0.4))*Math.PI*2;
          pts.push([-0.05 + 0.45*Math.cos(a), 0.15 + 0.55*Math.sin(a)]);
        }
        return pts;
      }
      function genTree(n){
        const pts = [];
        // canopy blob
        for(let i=0;i<n;i++){
          const a = i/n * Math.PI*2;
          const r = 0.75 + 0.12*Math.sin(3*a) + 0.08*Math.cos(5*a);
          pts.push([0 + r*Math.cos(a), -0.1 + r*0.75*Math.sin(a)]);
        }
        // trunk rectangle
        for(let i=0;i<n*0.25;i++){
          const u = i/(n*0.25);
          pts.push([ -0.15, 0.9*u + 0.2 ]);
          pts.push([  0.15, 0.9*u + 0.2 ]);
        }
        return pts;
      }

      const SHAPES = [
        () => genLeaf(140),
        () => genBird(120),
        () => genFace(110),
        () => genTree(120),
      ];

      function pickShapeWorld(cx,cy){
        const pts = SHAPES[Math.floor(Math.random()*SHAPES.length)]();
        // random size, rotation
        const size = (SHAPE_SIZE[0] + Math.random()*(SHAPE_SIZE[1]-SHAPE_SIZE[0]));
        const rot = (Math.random()*Math.PI*2);
        const cs = Math.cos(rot), sn = Math.sin(rot);
        // transform to world (CSS px), then to canvas (×dpr)
        return pts.map(([x,y])=>{
          const X = cx + (x*size*0.5*cs - y*size*0.5*sn);
          const Y = cy + (x*size*0.5*sn + y*size*0.5*cs);
          return { x: X*dpr, y: Y*dpr };
        });
      }

      function startAssembly(){
        assembling = true;
        assigned.length = 0; targets.length = 0;
        const cx = cursor.x, cy = cursor.y;
        // recruit local dots
        const local = [];
        const R = ASSEMBLY_RADIUS;
        const R2 = R*R;
        for(let i=0;i<dots.length;i++){
          const p = dots[i];
          const dx = p.x/dpr - cx, dy = p.y/dpr - cy;
          const d2 = dx*dx + dy*dy;
          if(d2 < R2) local.push({i, ang: Math.atan2(dy,dx), d: Math.sqrt(d2)});
        }
        if(!local.length) return;
        // sort by angle so mapping is coherent
        local.sort((a,b)=> a.ang - b.ang);
        const shapePts = pickShapeWorld(cx, cy);
        // also sort shape points by angle around center
        const sp = shapePts.map(pt => {
          const ang = Math.atan2(pt.y/dpr - cy, pt.x/dpr - cx);
          return {pt, ang};
        }).sort((a,b)=>a.ang-b.ang).map(o=>o.pt);

        const k = Math.min(local.length, sp.length);
        for(let i=0;i<k;i++){
          const idx = local[i].i;
          assigned.push(idx);
          targets.push({ x: sp[i].x, y: sp[i].y, phase: Math.random()*Math.PI*2 });
          dots[idx].tx = sp[i].x; dots[idx].ty = sp[i].y;
        }
      }

      function stopAssembly(){
        assembling = false;
        for(const i of assigned){
          dots[i].tx = NaN; dots[i].ty = NaN;
        }
        assigned.length = 0; targets.length = 0;
      }

      /* ---------- Main loop ---------- */
      let lastT = 0;
      function step(ts){
        if(!lastT) lastT = ts;
        lastT = ts;

        // smooth cursor
        if(!isFinite(cursor.x)){ cursor.x = cursor.tx; cursor.y = cursor.ty; }
        cursor.x += (cursor.tx - cursor.x) * EASE;
        cursor.y += (cursor.ty - cursor.y) * EASE;

        // decide assembly state
        const idle = (performance.now() - lastMove) > IDLE_MS && isFinite(cursor.tx);
        if(idle && !assembling) startAssembly();
        if(!idle && assembling) stopAssembly();

        // choose leader each frame (hook)
        if(isFinite(cursor.tx)){
          let best=-1, bestD2 = (HOOK_RADIUS*HOOK_RADIUS);
          for(let i=0;i<dots.length;i++){
            const p = dots[i];
            const dx = p.x/dpr - cursor.x, dy = p.y/dpr - cursor.y;
            const d2 = dx*dx + dy*dy;
            if(d2 < bestD2){ bestD2 = d2; best = i; }
          }
          leader = best;
        } else leader = -1;

        // prefetch leader
        let lx=0, ly=0;
        if(leader>=0){
          const L = dots[leader];
          lx = L.x; ly = L.y;
          L.vx += (cursor.x*dpr - L.x) * LEADER_STRENGTH;
          L.vy += (cursor.y*dpr - L.y) * LEADER_STRENGTH;
        }

        // clear frame
        ctx.clearRect(0,0,W,H);

        // animate dots
        for(let i=0;i<dots.length;i++){
          const p = dots[i];

          // spring toward origin (rest texture)
          p.vx += (p.ox - p.x) * SPRING;
          p.vy += (p.oy - p.y) * SPRING;

          // assembly pull for assigned dots
          if(assembling && !Number.isNaN(p.tx)){
            // slight breathing (organic micro-motion)
            const j = assigned.indexOf(i);
            const tgt = targets[j];
            const bx = Math.cos(tgt.phase + performance.now()*0.001)*SHAPE_BREATHE*dpr;
            const by = Math.sin(tgt.phase + performance.now()*0.0012)*SHAPE_BREATHE*dpr;
            p.vx += ((tgt.x + bx) - p.x) * SHAPE_PULL;
            p.vy += ((tgt.y + by) - p.y) * SHAPE_PULL;
          }

          // hook followers when moving
          if(leader>=0 && i!==leader){
            const dx = (lx - p.x), dy = (ly - p.y);
            const dist = Math.hypot(dx,dy);
            if(dist < FOLLOW_RADIUS*dpr){
              const w = (1 - dist/(FOLLOW_RADIUS*dpr));
              p.vx += dx * (FOLLOW_STRENGTH * w);
              p.vy += dy * (FOLLOW_STRENGTH * w);
              // gentle arc
              p.vx += (-dy) * 0.0006 * w;
              p.vy += ( dx) * 0.0006 * w;
            }
          }

          // tiny noise
          p.vx += (Math.random()-0.5)*NOISE;
          p.vy += (Math.random()-0.5)*NOISE;

          // integrate
          p.vx *= DAMP; p.vy *= DAMP;
          p.x  += p.vx; p.y  += p.vy;

          // draw
          const speed = Math.min(1, Math.hypot(p.vx, p.vy) / (1.0*dpr));
          // increase alpha slightly when assembling so silhouette reads
          const extra = assembling && !Number.isNaN(p.tx) ? 0.14 : 0.0;
          const a = baseAlpha + speed*0.18 + extra;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
          ctx.fillStyle = `rgba(${color},${a})`;
          ctx.fill();
        }

        requestAnimationFrame(step);
      }

      // mouse
      window.addEventListener('mousemove', (e)=>{
        cursor.tx = e.clientX;
        cursor.ty = e.clientY;
        lastMove = performance.now();
      }, {passive:true});
      window.addEventListener('mouseleave', ()=>{
        cursor.tx = cursor.ty = -1e9;
        stopAssembly();
      }, {passive:true});

      // init
      window.addEventListener('resize', resize);
      resize();
      requestAnimationFrame(step);
    })();

    // keep orb centered beneath the wordmark
    (function(){
      const orb  = document.getElementById('orb');
      const title= document.getElementById('title');
      const hero = document.getElementById('home');
      function centerOrb(){
        const r = title.getBoundingClientRect();
        const h = hero.getBoundingClientRect();
        const cx = r.left + r.width/2 - h.left;
        const cy = r.top  + r.height/2 - h.top;
        orb.style.left = cx + 'px';
        orb.style.top  = cy + 'px';
      }
      window.addEventListener('load', centerOrb);
      window.addEventListener('resize', () => requestAnimationFrame(centerOrb));
    })();
  </script>
</body>
</html>
